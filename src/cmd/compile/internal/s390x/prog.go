// Copyright 2014 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package s390x

import (
	"cmd/compile/internal/gc"
	"cmd/internal/obj"
	"cmd/internal/obj/s390x"
)

const (
	LeftRdwr  uint32 = gc.LeftRead | gc.LeftWrite
	RightRdwr uint32 = gc.RightRead | gc.RightWrite
)

// This table gives the basic information about instruction
// generated by the compiler and processed in the optimizer.
// See opt.h for bit definitions.
//
// Instructions not generated need not be listed.
// As an exception to that rule, we typically write down all the
// size variants of an operation even if we just use a subset.
//
// The table is formatted for 8-space tabs.
var progtable = [s390x.ALAST]obj.ProgInfo{
	obj.ATYPE:     {gc.Pseudo | gc.Skip, 0, 0, 0},
	obj.ATEXT:     {gc.Pseudo, 0, 0, 0},
	obj.AFUNCDATA: {gc.Pseudo, 0, 0, 0},
	obj.APCDATA:   {gc.Pseudo, 0, 0, 0},
	obj.AUNDEF:    {gc.Break, 0, 0, 0},
	obj.AUSEFIELD: {gc.OK, 0, 0, 0},
	obj.ACHECKNIL: {gc.LeftRead, 0, 0, 0},
	obj.AVARDEF:   {gc.Pseudo | gc.RightWrite, 0, 0, 0},
	obj.AVARKILL:  {gc.Pseudo | gc.RightWrite, 0, 0, 0},

	// NOP is an internal no-op that also stands
	// for USED and SET annotations, not the Power opcode.
	obj.ANOP: {gc.LeftRead | gc.RightWrite, 0, 0, 0},

	// Integer
	s390x.AADD:    {gc.SizeQ | gc.LeftRead | gc.RegRead | gc.RightWrite, 0, 0, 0},
	s390x.ASUB:    {gc.SizeQ | gc.LeftRead | gc.RegRead | gc.RightWrite, 0, 0, 0},
	s390x.ANEG:    {gc.SizeQ | gc.LeftRead | gc.RegRead | gc.RightWrite, 0, 0, 0},
	s390x.AAND:    {gc.SizeQ | gc.LeftRead | gc.RegRead | gc.RightWrite, 0, 0, 0},
	s390x.AOR:     {gc.SizeQ | gc.LeftRead | gc.RegRead | gc.RightWrite, 0, 0, 0},
	s390x.AXOR:    {gc.SizeQ | gc.LeftRead | gc.RegRead | gc.RightWrite, 0, 0, 0},
	s390x.AMULLD:  {gc.SizeQ | gc.LeftRead | gc.RegRead | gc.RightWrite, 0, 0, 0},
	s390x.AMULLW:  {gc.SizeL | gc.LeftRead | gc.RegRead | gc.RightWrite, 0, 0, 0},
	s390x.AMULHD:  {gc.SizeL | gc.LeftRead | gc.RegRead | gc.RightWrite, 0, 0, 0},
	s390x.AMULHDU: {gc.SizeL | gc.LeftRead | gc.RegRead | gc.RightWrite, 0, 0, 0},
	s390x.ADIVD:   {gc.SizeQ | gc.LeftRead | gc.RegRead | gc.RightWrite, 0, 0, 0},
	s390x.ADIVDU:  {gc.SizeQ | gc.LeftRead | gc.RegRead | gc.RightWrite, 0, 0, 0},
	s390x.ASLD:    {gc.SizeQ | gc.LeftRead | gc.RegRead | gc.RightWrite, 0, 0, 0},
	s390x.ASRD:    {gc.SizeQ | gc.LeftRead | gc.RegRead | gc.RightWrite, 0, 0, 0},
	s390x.ASRAD:   {gc.SizeQ | gc.LeftRead | gc.RegRead | gc.RightWrite, 0, 0, 0},
	s390x.ACMP:    {gc.SizeQ | gc.LeftRead | gc.RightRead, 0, 0, 0},
	s390x.ACMPU:   {gc.SizeQ | gc.LeftRead | gc.RightRead, 0, 0, 0},
	s390x.ATD:     {gc.SizeQ | gc.RightRead, 0, 0, 0},

	// Floating point.
	s390x.AFADD:   {gc.SizeD | gc.LeftRead | gc.RegRead | gc.RightWrite, 0, 0, 0},
	s390x.AFADDS:  {gc.SizeF | gc.LeftRead | gc.RegRead | gc.RightWrite, 0, 0, 0},
	s390x.AFSUB:   {gc.SizeD | gc.LeftRead | gc.RegRead | gc.RightWrite, 0, 0, 0},
	s390x.AFSUBS:  {gc.SizeF | gc.LeftRead | gc.RegRead | gc.RightWrite, 0, 0, 0},
	s390x.AFMUL:   {gc.SizeD | gc.LeftRead | gc.RegRead | gc.RightWrite, 0, 0, 0},
	s390x.AFMULS:  {gc.SizeF | gc.LeftRead | gc.RegRead | gc.RightWrite, 0, 0, 0},
	s390x.AFDIV:   {gc.SizeD | gc.LeftRead | gc.RegRead | gc.RightWrite, 0, 0, 0},
	s390x.AFDIVS:  {gc.SizeF | gc.LeftRead | gc.RegRead | gc.RightWrite, 0, 0, 0},
	s390x.AFCTIDZ: {gc.SizeF | gc.LeftRead | gc.RegRead | gc.RightWrite, 0, 0, 0},
	s390x.AFCFID:  {gc.SizeF | gc.LeftRead | gc.RegRead | gc.RightWrite, 0, 0, 0},
	s390x.AFCMPU:  {gc.SizeD | gc.LeftRead | gc.RightRead, 0, 0, 0},
	s390x.ACEBR:   {gc.SizeF | gc.LeftRead | gc.RightRead, 0, 0, 0},
	s390x.AFRSP:   {gc.SizeD | gc.LeftRead | gc.RightWrite | gc.Conv, 0, 0, 0},
	s390x.ALDEBR:  {gc.SizeD | gc.LeftRead | gc.RightWrite | gc.Conv, 0, 0, 0},
	s390x.AFSQRT:  {gc.SizeD | gc.LeftRead | gc.RightWrite, 0, 0, 0},

	// Conversions
	s390x.ACEFBRA: {gc.SizeF | gc.LeftRead | gc.RightWrite | gc.Conv, 0, 0, 0},
	s390x.ACDFBRA: {gc.SizeD | gc.LeftRead | gc.RightWrite | gc.Conv, 0, 0, 0},
	s390x.ACEGBRA: {gc.SizeF | gc.LeftRead | gc.RightWrite | gc.Conv, 0, 0, 0},
	s390x.ACDGBRA: {gc.SizeD | gc.LeftRead | gc.RightWrite | gc.Conv, 0, 0, 0},
	s390x.ACFEBRA: {gc.SizeL | gc.LeftRead | gc.RightWrite | gc.Conv, 0, 0, 0},
	s390x.ACFDBRA: {gc.SizeL | gc.LeftRead | gc.RightWrite | gc.Conv, 0, 0, 0},
	s390x.ACGEBRA: {gc.SizeQ | gc.LeftRead | gc.RightWrite | gc.Conv, 0, 0, 0},
	s390x.ACGDBRA: {gc.SizeQ | gc.LeftRead | gc.RightWrite | gc.Conv, 0, 0, 0},
	s390x.ACELFBR: {gc.SizeF | gc.LeftRead | gc.RightWrite | gc.Conv, 0, 0, 0},
	s390x.ACDLFBR: {gc.SizeD | gc.LeftRead | gc.RightWrite | gc.Conv, 0, 0, 0},
	s390x.ACELGBR: {gc.SizeF | gc.LeftRead | gc.RightWrite | gc.Conv, 0, 0, 0},
	s390x.ACDLGBR: {gc.SizeD | gc.LeftRead | gc.RightWrite | gc.Conv, 0, 0, 0},
	s390x.ACLFEBR: {gc.SizeL | gc.LeftRead | gc.RightWrite | gc.Conv, 0, 0, 0},
	s390x.ACLFDBR: {gc.SizeL | gc.LeftRead | gc.RightWrite | gc.Conv, 0, 0, 0},
	s390x.ACLGEBR: {gc.SizeQ | gc.LeftRead | gc.RightWrite | gc.Conv, 0, 0, 0},
	s390x.ACLGDBR: {gc.SizeQ | gc.LeftRead | gc.RightWrite | gc.Conv, 0, 0, 0},

	// Moves
	s390x.AMOVB:  {gc.SizeB | gc.LeftRead | gc.RightWrite | gc.Move | gc.Conv, 0, 0, 0},
	s390x.AMOVBU: {gc.SizeB | gc.LeftRead | gc.RightWrite | gc.Move | gc.Conv | gc.PostInc, 0, 0, 0},
	s390x.AMOVBZ: {gc.SizeB | gc.LeftRead | gc.RightWrite | gc.Move | gc.Conv, 0, 0, 0},
	s390x.AMOVH:  {gc.SizeW | gc.LeftRead | gc.RightWrite | gc.Move | gc.Conv, 0, 0, 0},
	s390x.AMOVHU: {gc.SizeW | gc.LeftRead | gc.RightWrite | gc.Move | gc.Conv | gc.PostInc, 0, 0, 0},
	s390x.AMOVHZ: {gc.SizeW | gc.LeftRead | gc.RightWrite | gc.Move | gc.Conv, 0, 0, 0},
	s390x.AMOVW:  {gc.SizeL | gc.LeftRead | gc.RightWrite | gc.Move | gc.Conv, 0, 0, 0},

	// there is no AMOVWU.
	s390x.AMOVWZU: {gc.SizeL | gc.LeftRead | gc.RightWrite | gc.Move | gc.Conv | gc.PostInc, 0, 0, 0},
	s390x.AMOVWZ:  {gc.SizeL | gc.LeftRead | gc.RightWrite | gc.Move | gc.Conv, 0, 0, 0},
	s390x.AMOVD:   {gc.SizeQ | gc.LeftRead | gc.RightWrite | gc.Move, 0, 0, 0},
	s390x.AMOVDU:  {gc.SizeQ | gc.LeftRead | gc.RightWrite | gc.Move | gc.PostInc, 0, 0, 0},
	s390x.AFMOVS:  {gc.SizeF | gc.LeftRead | gc.RightWrite | gc.Move | gc.Conv, 0, 0, 0},
	s390x.AFMOVD:  {gc.SizeD | gc.LeftRead | gc.RightWrite | gc.Move, 0, 0, 0},

	// Storage operations
	s390x.AMVC: {gc.SizeQ | gc.LeftRead | gc.RightRead, 0, 0, 0},
	s390x.ACLC: {gc.SizeQ | gc.LeftRead | gc.RightRead, 0, 0, 0},
	s390x.AXC:  {gc.SizeQ | gc.LeftRead | gc.RightRead, 0, 0, 0},
	s390x.AOC:  {gc.SizeQ | gc.LeftRead | gc.RightRead, 0, 0, 0},
	s390x.ANC:  {gc.SizeQ | gc.LeftRead | gc.RightRead, 0, 0, 0},

	// Jumps
	s390x.ABR:      {gc.Jump | gc.Break, 0, 0, 0},
	s390x.ABL:      {gc.Call, 0, 0, 0},
	s390x.ABEQ:     {gc.Cjmp, 0, 0, 0},
	s390x.ABNE:     {gc.Cjmp, 0, 0, 0},
	s390x.ABGE:     {gc.Cjmp, 0, 0, 0},
	s390x.ABLT:     {gc.Cjmp, 0, 0, 0},
	s390x.ABGT:     {gc.Cjmp, 0, 0, 0},
	s390x.ABLE:     {gc.Cjmp, 0, 0, 0},
	s390x.ACMPBEQ:  {gc.Cjmp, 0, 0, 0},
	s390x.ACMPBNE:  {gc.Cjmp, 0, 0, 0},
	s390x.ACMPBGE:  {gc.Cjmp, 0, 0, 0},
	s390x.ACMPBLT:  {gc.Cjmp, 0, 0, 0},
	s390x.ACMPBGT:  {gc.Cjmp, 0, 0, 0},
	s390x.ACMPBLE:  {gc.Cjmp, 0, 0, 0},
	s390x.ACMPUBEQ: {gc.Cjmp, 0, 0, 0},
	s390x.ACMPUBNE: {gc.Cjmp, 0, 0, 0},
	s390x.ACMPUBGE: {gc.Cjmp, 0, 0, 0},
	s390x.ACMPUBLT: {gc.Cjmp, 0, 0, 0},
	s390x.ACMPUBGT: {gc.Cjmp, 0, 0, 0},
	s390x.ACMPUBLE: {gc.Cjmp, 0, 0, 0},

	obj.ARET:      {gc.Break, 0, 0, 0},
	obj.ADUFFZERO: {gc.Call, 0, 0, 0},
	obj.ADUFFCOPY: {gc.Call, 0, 0, 0},
}

var initproginfo_initialized int

func initproginfo() {
	var addvariant = []int{V_CC, V_V, V_CC | V_V}

	if initproginfo_initialized != 0 {
		return
	}
	initproginfo_initialized = 1

	// Perform one-time expansion of instructions in progtable to
	// their CC, V, and VCC variants
	var as2 int
	var i int
	var variant int
	for as := int(0); as < len(progtable); as++ {
		if progtable[as].Flags == 0 {
			continue
		}
		variant = as2variant(as)
		for i = 0; i < len(addvariant); i++ {
			as2 = variant2as(as, variant|addvariant[i])
			if as2 != 0 && progtable[as2].Flags == 0 {
				progtable[as2] = progtable[as]
			}
		}
	}
}

func proginfo(p *obj.Prog) {
	initproginfo()

	info := &p.Info
	*info = progtable[p.As]
	if info.Flags == 0 {
		gc.Fatal("proginfo: unknown instruction %v", p)
	}

	if (info.Flags&gc.RegRead != 0) && p.Reg == 0 {
		info.Flags &^= gc.RegRead
		info.Flags |= gc.RightRead /*CanRegRead |*/
	}

	if (p.From.Type == obj.TYPE_MEM || p.From.Type == obj.TYPE_ADDR) && p.From.Reg != 0 {
		info.Regindex |= RtoB(int(p.From.Reg))
		if info.Flags&gc.PostInc != 0 {
			info.Regset |= RtoB(int(p.From.Reg))
		}
	}

	if (p.To.Type == obj.TYPE_MEM || p.To.Type == obj.TYPE_ADDR) && p.To.Reg != 0 {
		info.Regindex |= RtoB(int(p.To.Reg))
		if info.Flags&gc.PostInc != 0 {
			info.Regset |= RtoB(int(p.To.Reg))
		}
	}

	if p.From.Type == obj.TYPE_ADDR && p.From.Sym != nil && (info.Flags&gc.LeftRead != 0) {
		info.Flags &^= gc.LeftRead
		info.Flags |= gc.LeftAddr
	}

	if p.As == obj.ADUFFZERO {
		info.Reguse |= 1<<0 | RtoB(s390x.REG_R3)
		info.Regset |= RtoB(s390x.REG_R3)
	}

	if p.As == obj.ADUFFCOPY {
		// TODO(austin) Revisit when duffcopy is implemented
		info.Reguse |= RtoB(s390x.REG_R3) | RtoB(s390x.REG_R4) | RtoB(s390x.REG_R5)

		info.Regset |= RtoB(s390x.REG_R3) | RtoB(s390x.REG_R4)
	}
}

// Instruction variants table.  Initially this contains entries only
// for the "base" form of each instruction.  On the first call to
// as2variant or variant2as, we'll add the variants to the table.
var varianttable = [s390x.ALAST][4]int{
	s390x.AADD:     [4]int{s390x.AADD, s390x.AADDCC, s390x.AADDV, s390x.AADDVCC},
	s390x.AADDC:    [4]int{s390x.AADDC, s390x.AADDCCC, s390x.AADDCV, s390x.AADDCVCC},
	s390x.AADDE:    [4]int{s390x.AADDE, s390x.AADDECC, s390x.AADDEV, s390x.AADDEVCC},
	s390x.AADDME:   [4]int{s390x.AADDME, s390x.AADDMECC, s390x.AADDMEV, s390x.AADDMEVCC},
	s390x.AADDZE:   [4]int{s390x.AADDZE, s390x.AADDZECC, s390x.AADDZEV, s390x.AADDZEVCC},
	s390x.AAND:     [4]int{s390x.AAND, s390x.AANDCC, 0, 0},
	s390x.AANDN:    [4]int{s390x.AANDN, s390x.AANDNCC, 0, 0},
	s390x.ACNTLZD:  [4]int{s390x.ACNTLZD, s390x.ACNTLZDCC, 0, 0},
	s390x.ACNTLZW:  [4]int{s390x.ACNTLZW, s390x.ACNTLZWCC, 0, 0},
	s390x.ADIVD:    [4]int{s390x.ADIVD, s390x.ADIVDCC, s390x.ADIVDV, s390x.ADIVDVCC},
	s390x.ADIVDU:   [4]int{s390x.ADIVDU, s390x.ADIVDUCC, s390x.ADIVDUV, s390x.ADIVDUVCC},
	s390x.ADIVW:    [4]int{s390x.ADIVW, s390x.ADIVWCC, s390x.ADIVWV, s390x.ADIVWVCC},
	s390x.ADIVWU:   [4]int{s390x.ADIVWU, s390x.ADIVWUCC, s390x.ADIVWUV, s390x.ADIVWUVCC},
	s390x.AEQV:     [4]int{s390x.AEQV, s390x.AEQVCC, 0, 0},
	s390x.AEXTSB:   [4]int{s390x.AEXTSB, s390x.AEXTSBCC, 0, 0},
	s390x.AEXTSH:   [4]int{s390x.AEXTSH, s390x.AEXTSHCC, 0, 0},
	s390x.AEXTSW:   [4]int{s390x.AEXTSW, s390x.AEXTSWCC, 0, 0},
	s390x.AFABS:    [4]int{s390x.AFABS, s390x.AFABSCC, 0, 0},
	s390x.AFADD:    [4]int{s390x.AFADD, s390x.AFADDCC, 0, 0},
	s390x.AFADDS:   [4]int{s390x.AFADDS, s390x.AFADDSCC, 0, 0},
	s390x.AFCFID:   [4]int{s390x.AFCFID, s390x.AFCFIDCC, 0, 0},
	s390x.AFCTID:   [4]int{s390x.AFCTID, s390x.AFCTIDCC, 0, 0},
	s390x.AFCTIDZ:  [4]int{s390x.AFCTIDZ, s390x.AFCTIDZCC, 0, 0},
	s390x.AFCTIW:   [4]int{s390x.AFCTIW, s390x.AFCTIWCC, 0, 0},
	s390x.AFCTIWZ:  [4]int{s390x.AFCTIWZ, s390x.AFCTIWZCC, 0, 0},
	s390x.AFDIV:    [4]int{s390x.AFDIV, s390x.AFDIVCC, 0, 0},
	s390x.AFDIVS:   [4]int{s390x.AFDIVS, s390x.AFDIVSCC, 0, 0},
	s390x.AFMADD:   [4]int{s390x.AFMADD, s390x.AFMADDCC, 0, 0},
	s390x.AFMADDS:  [4]int{s390x.AFMADDS, s390x.AFMADDSCC, 0, 0},
	s390x.AFMOVD:   [4]int{s390x.AFMOVD, s390x.AFMOVDCC, 0, 0},
	s390x.AFMSUB:   [4]int{s390x.AFMSUB, s390x.AFMSUBCC, 0, 0},
	s390x.AFMSUBS:  [4]int{s390x.AFMSUBS, s390x.AFMSUBSCC, 0, 0},
	s390x.AFMUL:    [4]int{s390x.AFMUL, s390x.AFMULCC, 0, 0},
	s390x.AFMULS:   [4]int{s390x.AFMULS, s390x.AFMULSCC, 0, 0},
	s390x.AFNABS:   [4]int{s390x.AFNABS, s390x.AFNABSCC, 0, 0},
	s390x.AFNEG:    [4]int{s390x.AFNEG, s390x.AFNEGCC, 0, 0},
	s390x.AFNMADD:  [4]int{s390x.AFNMADD, s390x.AFNMADDCC, 0, 0},
	s390x.AFNMADDS: [4]int{s390x.AFNMADDS, s390x.AFNMADDSCC, 0, 0},
	s390x.AFNMSUB:  [4]int{s390x.AFNMSUB, s390x.AFNMSUBCC, 0, 0},
	s390x.AFNMSUBS: [4]int{s390x.AFNMSUBS, s390x.AFNMSUBSCC, 0, 0},
	s390x.AFRES:    [4]int{s390x.AFRES, s390x.AFRESCC, 0, 0},
	s390x.AFRSP:    [4]int{s390x.AFRSP, s390x.AFRSPCC, 0, 0},
	s390x.AFRSQRTE: [4]int{s390x.AFRSQRTE, s390x.AFRSQRTECC, 0, 0},
	s390x.AFSEL:    [4]int{s390x.AFSEL, s390x.AFSELCC, 0, 0},
	s390x.AFSQRT:   [4]int{s390x.AFSQRT, s390x.AFSQRTCC, 0, 0},
	s390x.AFSQRTS:  [4]int{s390x.AFSQRTS, s390x.AFSQRTSCC, 0, 0},
	s390x.AFSUB:    [4]int{s390x.AFSUB, s390x.AFSUBCC, 0, 0},
	s390x.AFSUBS:   [4]int{s390x.AFSUBS, s390x.AFSUBSCC, 0, 0},
	s390x.AMTFSB0:  [4]int{s390x.AMTFSB0, s390x.AMTFSB0CC, 0, 0},
	s390x.AMTFSB1:  [4]int{s390x.AMTFSB1, s390x.AMTFSB1CC, 0, 0},
	s390x.AMULHD:   [4]int{s390x.AMULHD, s390x.AMULHDCC, 0, 0},
	s390x.AMULHDU:  [4]int{s390x.AMULHDU, s390x.AMULHDUCC, 0, 0},
	s390x.AMULHW:   [4]int{s390x.AMULHW, s390x.AMULHWCC, 0, 0},
	s390x.AMULHWU:  [4]int{s390x.AMULHWU, s390x.AMULHWUCC, 0, 0},
	s390x.AMULLD:   [4]int{s390x.AMULLD, s390x.AMULLDCC, s390x.AMULLDV, s390x.AMULLDVCC},
	s390x.AMULLW:   [4]int{s390x.AMULLW, s390x.AMULLWCC, s390x.AMULLWV, s390x.AMULLWVCC},
	s390x.ANAND:    [4]int{s390x.ANAND, s390x.ANANDCC, 0, 0},
	s390x.ANEG:     [4]int{s390x.ANEG, s390x.ANEGCC, s390x.ANEGV, s390x.ANEGVCC},
	s390x.ANOR:     [4]int{s390x.ANOR, s390x.ANORCC, 0, 0},
	s390x.AOR:      [4]int{s390x.AOR, s390x.AORCC, 0, 0},
	s390x.AORN:     [4]int{s390x.AORN, s390x.AORNCC, 0, 0},
	s390x.AREM:     [4]int{s390x.AREM, s390x.AREMCC, s390x.AREMV, s390x.AREMVCC},
	s390x.AREMD:    [4]int{s390x.AREMD, s390x.AREMDCC, s390x.AREMDV, s390x.AREMDVCC},
	s390x.AREMDU:   [4]int{s390x.AREMDU, s390x.AREMDUCC, s390x.AREMDUV, s390x.AREMDUVCC},
	s390x.AREMU:    [4]int{s390x.AREMU, s390x.AREMUCC, s390x.AREMUV, s390x.AREMUVCC},
	s390x.ARLDC:    [4]int{s390x.ARLDC, s390x.ARLDCCC, 0, 0},
	s390x.ARLDCL:   [4]int{s390x.ARLDCL, s390x.ARLDCLCC, 0, 0},
	s390x.ARLDCR:   [4]int{s390x.ARLDCR, s390x.ARLDCRCC, 0, 0},
	s390x.ARLDMI:   [4]int{s390x.ARLDMI, s390x.ARLDMICC, 0, 0},
	s390x.ARLWMI:   [4]int{s390x.ARLWMI, s390x.ARLWMICC, 0, 0},
	s390x.ARLWNM:   [4]int{s390x.ARLWNM, s390x.ARLWNMCC, 0, 0},
	s390x.ASLD:     [4]int{s390x.ASLD, s390x.ASLDCC, 0, 0},
	s390x.ASLW:     [4]int{s390x.ASLW, s390x.ASLWCC, 0, 0},
	s390x.ASRAD:    [4]int{s390x.ASRAD, s390x.ASRADCC, 0, 0},
	s390x.ASRAW:    [4]int{s390x.ASRAW, s390x.ASRAWCC, 0, 0},
	s390x.ASRD:     [4]int{s390x.ASRD, s390x.ASRDCC, 0, 0},
	s390x.ASRW:     [4]int{s390x.ASRW, s390x.ASRWCC, 0, 0},
	s390x.ASUB:     [4]int{s390x.ASUB, s390x.ASUBCC, s390x.ASUBV, s390x.ASUBVCC},
	s390x.ASUBC:    [4]int{s390x.ASUBC, s390x.ASUBCCC, s390x.ASUBCV, s390x.ASUBCVCC},
	s390x.ASUBE:    [4]int{s390x.ASUBE, s390x.ASUBECC, s390x.ASUBEV, s390x.ASUBEVCC},
	s390x.ASUBME:   [4]int{s390x.ASUBME, s390x.ASUBMECC, s390x.ASUBMEV, s390x.ASUBMEVCC},
	s390x.ASUBZE:   [4]int{s390x.ASUBZE, s390x.ASUBZECC, s390x.ASUBZEV, s390x.ASUBZEVCC},
	s390x.AXOR:     [4]int{s390x.AXOR, s390x.AXORCC, 0, 0},
}

var initvariants_initialized int

func initvariants() {
	if initvariants_initialized != 0 {
		return
	}
	initvariants_initialized = 1

	var j int
	for i := int(0); i < len(varianttable); i++ {
		if varianttable[i][0] == 0 {
			// Instruction has no variants
			varianttable[i][0] = i

			continue
		}

		// Copy base form to other variants
		if varianttable[i][0] == i {
			for j = 0; j < len(varianttable[i]); j++ {
				varianttable[varianttable[i][j]] = varianttable[i]
			}
		}
	}
}

// as2variant returns the variant (V_*) flags of instruction as.
func as2variant(as int) int {
	initvariants()
	for i := int(0); i < len(varianttable[as]); i++ {
		if varianttable[as][i] == as {
			return i
		}
	}
	gc.Fatal("as2variant: instruction %v is not a variant of itself", obj.Aconv(as))
	return 0
}

// variant2as returns the instruction as with the given variant (V_*) flags.
// If no such variant exists, this returns 0.
func variant2as(as int, flags int) int {
	initvariants()
	return varianttable[as][flags]
}
